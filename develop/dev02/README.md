На задание 2 было сделано 2 решения:
* Наивное

Дает возможность пошагового выполнения распаковки и возможность заглянуть в прогресс. Вся логика в функции Step, из-за чего она стала слишком большой

* С использование паттерна состояние

Выделены состояния: Начало, Символ, Цифра, Escape и Окончание. Это позволило вынести логику в каждый отдельный класс, что облегчило разработку и чтение логики на каждом шаге FSM'а


### Бенчмарки

Первые бенчмарки - просто функция Unpack с повторной переинициализации структур

Benchmark*2 - бенчмарки, не учитывающие инциализацию всех структур 

```
goos: linux
goarch: amd64
pkg: github.com/Wmuga/wildberries-l2/develop/dev02
cpu: AMD Ryzen 5 5600H with Radeon Graphics         
BenchmarkNaive-12        1000000              3212 ns/op             600 B/op          7 allocs/op
BenchmarkState-12         440586              3162 ns/op             728 B/op         12 allocs/op
BenchmarkNaive2-12        535644              3368 ns/op             600 B/op          7 allocs/op
BenchmarkState2-12       1220516              1052 ns/op             883 B/op          1 allocs/op
```

### Вывод

Как видно из бенчмарков, с учетом инициализации побеждает "Наивное решение", так как в нем почти нечего инициализировать. Однако если откинуть этап инициализации, начинает выигрывать второй с и по скорости и по памяти с 1 аллокацией на операцию. Так как во время долгого использования одной логики пересоздавать основную структуру не имеет сыысла, побеждает вторая реализация (паттерн состояние)